{"title":"Practical UML Statecharts in C/C++, Second Edition","uid":4748937,"size":14332870,"categoryP":"other","categoryS":"e_books","magnet":"?xt=urn:btih:781a1f90006d0dd495adcdf83513ffe25afc40b2&amp;dn=Practical+UML+Statecharts+in+C%2FC%2B%2B%2C+Second+Edition&amp;tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&amp;tr=udp%3A%2F%2Fopen.demonii.com%3A1337&amp;tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&amp;tr=udp%3A%2F%2Fexodus.desync.com%3A6969","seeders":2,"leechers":1,"uploader":"VasiaZozulia","files":1,"time":1236039270,"description":"Practical UML Statecharts in C/C++ Second Edition bridges the gap between high-level abstract concepts of the Unified Modeling Language (UML) and the actual programming aspects of modern hierarchical state machines (UML statecharts). The book describes a lightweight, open source, event-driven infrastructure, called QP that enables direct manual coding UML statecharts and concurrent event-driven applications in C or C++ without big tools.\nThis book is presented in two parts. In Part I, you get a practical description of the relevant state machine concepts starting from traditional finite state automata to modern UML state machines followed by state machine coding techniques and state-machine design patterns, all illustrated with executable examples. In Part II, you find a detailed design study of a generic real-time framework indispensable for combining concurrent, event-driven state machines into robust applications. Part II begins with a clear explanation of the key event-driven programming concepts such as inversion of control (Hollywood Principle), blocking versus non-blocking code, run-to-completion (RTC) execution semantics, the importance of event queues, dealing with time, and the role of state machines to maintain the context from one event to the next. This background is designed to help software developers in making the transition from the traditional sequential to the modern event-driven programming, which can be one of the trickiest paradigm shifts.\nThe lightweight QP event-driven infrastructure goes several steps beyond the traditional real-time operating system (RTOS). In the simplest configuration, QP runs on bare-metal microprocessor, microcontroller, or DSP completely replacing the RTOS. QP can also work with almost any OS/RTOS to take advantage of the existing device drivers, communication stacks, and other middleware. The accompanying website to this book contains complete open source code for QP, ports to popular processors and operating systems, including 80x86, ARM Cortex-M3, MSP430, and Linux, as well as all examples described in the book.\n\n*Focuses on core concepts rather than tools which are always changing allowing the reader to continue to use this information with various projects\n*Provides a complete, ready-to-use, open source software architecture for small and large embedded systems\n*Includes an extensive example using the ARM Cortex-M3 throughout the book highlighting issues programmers and architects encounter in everyday life","torrent":{"xt":"urn:btih:781a1f90006d0dd495adcdf83513ffe25afc40b2","amp;dn":"Practical+UML+Statecharts+in+C%2FC%2B%2B%2C+Second+Edition","amp;tr":["udp%3A%2F%2Ftracker.openbittorrent.com%3A80","udp%3A%2F%2Fopen.demonii.com%3A1337","udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969","udp%3A%2F%2Fexodus.desync.com%3A6969"],"infoHash":"781a1f90006d0dd495adcdf83513ffe25afc40b2","infoHashBuffer":{"type":"Buffer","data":[120,26,31,144,0,109,13,212,149,173,205,248,53,19,255,226,90,252,64,178]},"announce":[],"urlList":[]}}